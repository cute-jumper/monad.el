#+TITLE: monad.el

(WIP) Toy implementation of monads in Emacs Lisp.

*Just for fun! Don't take this seriously!*

Note: The lexical binding must be enabled to make this work

* Do Notation
  : (monad-do type
  :    &rest body)

  Currently, the type can be one of
  - =Maybe=
  - =List=
  - =Reader=
  - =Writer=
  - =State=

  The body contains a list of sexps in the form of =(var monad)= except for the
  last expression. If you don't want to bind anything, use =(_ monad)= or just
  =(monad)=. Since =do= notation doesn't allow you to bind any variable in the
  last expression, so the last expression is only =monad=, not =(monad)=. Whthin
  the body, =return= is also allowed.

  Some of the following code are based on examples of [[http://learnyouahaskell.com/]].

* Maybe Monad
  #+BEGIN_SRC elisp
  (monad-do Maybe
    (x (Just 4))
    (y (if (= x 4)
           (return 5)
         Nothing))
    (return (+ x y)))
  ;; => (Just . 9)
  #+END_SRC

  How can this be useful in real world scenarios? For example, in [[https://github.com/cute-jumper/org2elcomment][org2elcomment]],
  we need to search inside an Emacs Lisp source code file to find the two lines:
  =;;; Commentary:= and =;;; Code:=, and insert the comment between these two
  lines. If one of the searches fails, the whole process fails. Here is how to
  use =Maybe= monad in this scenario:
  #+BEGIN_SRC elisp
  (monad-do Maybe
    (beg (Maybe<-
          (save-excursion
            (goto-char (point-min))
            (re-search-forward ";;; Commentary:$" nil t))))
    (end (Maybe<-
          (save-excursion
            (goto-char (point-min))
            (re-search-forward ";;; Code:$" nil t))))
    (return (cons beg end)))
  #+END_SRC

  The code is much simplified since we only need to consider the successful
  path. =Maybe<-= is a simple macro to convert the return value of its last
  argument into a =Maybe= value: =nil= to =Nothing= and anything else is =Just
  something=:
  #+BEGIN_SRC elisp
  (Maybe<-
    (+ 1 2)
    (eq 'too 'naive)) ; => Nothing
  (Maybe<-
    (eq 'too 'simple)
    (* 2 3)) ; => (Just . 6)
  #+END_SRC

* List Monad
  #+BEGIN_SRC elisp
  (monad-do List
    (x (List 2 3 4))
    (y (List 5 6 7))
    (return (cons x y)))
  ;; => ((2 . 5) (2 . 6) (2 . 7) (3 . 5) (3 . 6) (3 . 7) (4 . 5) (4 . 6) (4 . 7))
  #+END_SRC

* Reader Monad
  #+BEGIN_SRC elisp
  (Reader-run
   (monad-do Reader
     (x (apply-partially '* 2))
     (y (apply-partially '+ 10))
     (return (+ x y)))
   3)
  ;; => 19
  #+END_SRC

* Writer Monad
  #+BEGIN_SRC elisp
  (defun log-number (x)
    (Writer x (list (format "Got number: %s" x))))

  (monad-do Writer
    (x (log-number 3))
    (y (log-number 5))
    (return (* x y)))
  ;; => (Writer 15 "Got number: 3" "Got number: 5")
  #+END_SRC

* State Monad
  #+BEGIN_SRC elisp
  (defun stack-pop ()
    (State (lambda (s) (list (car s) (cdr s)))))

  (defun stack-push (a)
    (State (lambda (s) (list nil (cons a s)))))

  (State-run
   (monad-do State
     (x (State-get))
     (y (stack-pop))
     (z (stack-pop))
     ((if (= (length x) 3)
          (State-put '(200))
        (State-put '(100))))
     ((stack-push y))
     (_ (stack-push z))
     (return x))
   '(8 9 10))
  ;; => ((8 9 10) 9 8 200)
  #+END_SRC
